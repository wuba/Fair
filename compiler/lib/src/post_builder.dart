/*
 * Copyright (C) 2005-present, 58.com.  All rights reserved.
 * Use of this source code is governed by a BSD type license that can be
 * found in the LICENSE file.
 */

import 'dart:async';
import 'dart:io';

import 'package:archive/archive.dart';
import 'package:build/build.dart';
import 'package:crypto/crypto.dart' show md5;
import 'package:fair_compiler/src/state_transfer.dart';
import 'package:fair_dart2dsl/fairc.dart' as dart2dsl;
import 'package:fair_dart2dsl/src/helper.dart' show ModuleNameHelper;
import 'package:fair_dart2js/index.dart' as dart2js;
import 'package:intl/intl.dart';
import 'package:path/path.dart' as path;
import 'package:yaml/yaml.dart';

import 'helper.dart' show FlatCompiler;

class ArchiveBuilder extends PostProcessBuilder with FlatCompiler {
  bool generated = false;

  @override
  FutureOr<void> build(PostProcessBuildStep buildStep) async {
    if (generated) {
      return;
    }
    generated = true;
    var buildDir =
        Directory(path.join('.dart_tool', 'build', 'fairc', 'build'));
    if (!buildDir.existsSync()) {
      return;
    }
    var files = await buildDir
        .list(recursive: true)
        .map((element) => element.absolute.path)
        .where((event) => event.endsWith('.dart'))
        .toList();

    final dir = path.join('build', 'fair');
    Directory(dir).createSync(recursive: true);
    // dart2dsl
    try {
      await dart2dsl
          .dart2dsl(['-k', 'bundleDir', '-d', buildDir.absolute.path]);
    } catch (e, s) {
      var errorLog = await File(path.join('build', 'fair', 'log',
              '${DateFormat('yyyy-MM-dd_HH:mm:sss').format(DateTime.now())}.txt'))
          .create(recursive: true);
      var f = await errorLog.open(mode: FileMode.append);
      await f.writeString('error:\n${e.toString()}\nstack:\n${s.toString()}\n');
    }

    var isOutputBin = false;
    for (var filePath in files) {
      var moduleNameKey = path.withoutExtension(filePath);
      var moduleNameValue = ModuleNameHelper().modules[moduleNameKey];
      final bundleFilePath = path.join(
          dir,
          filePath
              .replaceFirst(buildDir.absolute.path, '')
              .replaceFirst('/', '')
              .replaceAll('lib', moduleNameValue)
              .replaceAll('/', '_')
              .replaceAll('\\', '_')
              .replaceAll('.dart', '.fair.json'));
      final jsFilePath = bundleFilePath.replaceFirst('.fair.json', '.fair.js');
      await dart2JS(filePath, jsFilePath);
      isOutputBin = await compileBundle(bundleFilePath);
    }

    // 压缩下发产物
    var zipSrcPath = path.join(Directory.current.path, 'build', 'fair');
    var zipDesPath =
        path.join(Directory.current.path, 'build', 'fair', 'fair_patch.zip');
    _zip(Directory(zipSrcPath), File(zipDesPath), isOutputBin);

    // delete buildDir
    await buildDir.delete(recursive: true);
    await stateTransfer();
  }

  @override
  Iterable<String> get inputExtensions => ['.dart.temp'];

  Future dart2JS(String filePath, String jsFilePath) async {
    print('\u001b[33m [Fair Dart2JS] partPath => $filePath \u001b[0m');
    if (File(filePath).existsSync()) {
      try {
        var uglify = true;
        var optionsYamlPath =
            path.join(Directory.current.path, 'fair_compiler_options.yaml');
        var optionYamlFile = File(optionsYamlPath);
        if (optionYamlFile.existsSync()) {
          var optionsYaml =
              loadYaml(optionYamlFile.readAsStringSync()) as YamlMap?;
          if (optionsYaml != null && optionsYaml.containsKey('uglify')) {
            uglify = optionsYaml['uglify'];
          }
        }
        print('\u001b[33m [Fair Dart2JS] uglify option: => $uglify \u001b[0m');
        var result = await dart2js.convertFile(filePath, uglify);
        File(jsFilePath).writeAsStringSync(result);
      } catch (e) {
        print('[Fair Dart2JS] e => $e');
      }
    }
  }

  Future<bool> compileBundle(String bundleFilePath) async {
    var bundleFile = File(bundleFilePath);
    if (!bundleFile.existsSync()) {
      return false;
    }
    final bytes = await bundleFile.readAsBytes();
    var bin = await compile(bundleFile.absolute.path);
    if (bin.success) {
      print('[Fair] FlatBuffer format generated for ${bundleFile.path}');
    } else {
      print('error: [Fair] FlatBuffer format fail ${bin.message}');
    }
    final buffer = StringBuffer();
    buffer.writeln('# Generated by Fair on ${DateTime.now()}.\n');
    final source = bundleFilePath.replaceAll(inputExtensions.first, '.dart');
    buffer.writeln('source: $source');
    final digest = md5.convert(bytes).toString();
    buffer.writeln('md5: $digest');
    buffer.writeln('json: ${bundleFile.path}');
    if (bin.success) {
      buffer.writeln('bin: ${bin.data}');
    }
    buffer.writeln('date: ${DateTime.now()}');
    File('${bundleFilePath.replaceAll('.json', '.metadata')}')
        .writeAsStringSync(buffer.toString());

    print('[Fair] New bundle generated => $bundleFilePath');

    return bin.success;
  }

  void _zip(Directory data, File zipFile, bool isOutputBin) {
    final js_file_extension = '.js';
    final dsl_file_extension = isOutputBin ? '.bin' : '.json';

    final archive = Archive();
    for (var entity in data.listSync(recursive: false)) {
      if (entity is! File) {
        continue;
      }
      if (entity.path.endsWith(js_file_extension) ||
          entity.path.endsWith(dsl_file_extension)) {
        final file = entity;
        var filename = file.path.split(Platform.pathSeparator).last;
        final List<int> bytes = file.readAsBytesSync();
        archive.addFile(ArchiveFile(filename, bytes.length, bytes));
      }
    }
    var encode = ZipEncoder().encode(archive);
    if (encode == null) return;
    zipFile.writeAsBytesSync(encode, flush: false);
  }
}
